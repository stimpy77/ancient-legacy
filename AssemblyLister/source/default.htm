<html>
<body>
<pre>
<code><span style="font: 10pt Courier New;"><span class="html1-text">// ====================================
//          AssemblyLister
// ====================================
//
// Author:	Jon Davis &lt;</span><span class="html1-unknownword">jon</span><span class="html1-identifier">@jondavis.net&gt;
// 		    http://www.jondavis.net/
//
// Date:	4/10/2006
//
// ====================================
// Abstract:
// ====================================
// This is a console application that will search for
// CLR-loadable assemblies in a specified path and
// also optionally execute ngen.exe which should be
// located in the path identified by the &quot;CLRDIR&quot;
// environment variable.
//
// ====================================
// To build:
// ====================================
// Create a console app in Visual Studio 2005 and
// replace the contents of Program.cs with the entire
// content of this web page. In the project properties,
// I recommend naming the assembly &quot;AssemLst.exe&quot;.
// Once built, I also recommend copying it to your
// Framework directory, e.g.
// C:\Windows\Microsoft.net\Framework\v2.*\
//
// ====================================
// To use:
// ====================================
// Just execute ...
//
//   AssemLst.exe /?
//
// ... to learn how to use the console application.
//
// ====================================
// Your license:
// ====================================
// You may compile this console app for personal
// use. You may not redistribute the compiled
// application, but you may redistribute this source
// as long as author credit is recognized.
//


using System;
using System.Collections.Specialized;
using System.Reflection;
using System.IO;

namespace AssemblyLister
{
    class Program
    {
        static System.IO.FileInfo fi = new FileInfo(Assembly.GetExecutingAssembly().Location);
        static string BaseArgHelp = &quot;\r\n&quot;
                + fi.Name + &quot; [ -s ] [ -ngen [ -uninstall ] ] [ directory or file ]\r\n\r\n&quot;
                + &quot;Evaluates the specified file(s) or directory(ies) to determine whether they are CLR-loadable assemblies.\r\n\r\n&quot;
                + &quot;-s\t\t\tScans subdirectories. (Default is DISABLED.)\r\n\n&quot;
                + &quot;-v\t\t\tVerbose mode. (Default is DISABLED.)\r\n\n&quot;
                + &quot;-ngen [-uninstall]\tInstalls [or uninstalls] the assembly by pre-JIT'ing\r\n\t\t\twith ngen.exe.&quot;
                + &quot; (Default is DISABLED.)\r\n\n&quot;
                + &quot;[directory]\t\tScans the specified path for CLR assembly files.\r\n&quot;
                + &quot;\t\t\tMatches are listed.\r\n\n&quot;
                + &quot;[file]\t\t\tScans the specified file to determine if it is an\r\n&quot;
                + &quot;\t\t\tassembly file. If it is, the path is repeated.\r\n\n&quot;;
        static void Main(string[] args)
        {
            bool bFollowSubDirs = false;
            bool bNgen = false;
            bool bVerbose = false;
            bool bNgenUninstall = false;
            int f = 0;
            for (int i = 0; i &lt; </span><span class="html1-unknownword">args</span><span class="html1-identifier">.Length; i++)
            {
                string arg = </span><span class="html1-value">args[i];
</span><span class="html1-space">                if (arg.StartsWith(</span><span class="html1-value">&quot;-&quot;</span><span class="html1-identifier">) || arg.StartsWith(</span><span class="html1-value">&quot;/&quot;</span><span class="html1-identifier">))
                {
                    switch (arg.ToLower())
                    {
                        case </span><span class="html1-value">&quot;-s&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;/s&quot;</span><span class="html1-identifier">:
                            bFollowSubDirs = </span><span class="html1-value">true;
</span><span class="html1-space">                            break;
                        case </span><span class="html1-value">&quot;-v&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;/v&quot;</span><span class="html1-identifier">:
                            bVerbose = </span><span class="html1-value">true;
</span><span class="html1-space">                            break;
                        case </span><span class="html1-value">&quot;-ngen&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;/ngen&quot;</span><span class="html1-identifier">:
                            bNgen = </span><span class="html1-value">true;
</span><span class="html1-space">                            try
                            {
                                if (args[i + 1].ToLower() == </span><span class="html1-value">&quot;-uninstall&quot;</span><span class="html1-space"> || args[i + 1].ToLower() == </span><span class="html1-value">&quot;/uninstall&quot;</span><span class="html1-identifier">)
                                {
                                    bNgenUninstall = </span><span class="html1-value">true;
</span><span class="html1-space">                                    i++;
                                }
                            }
                            catch { }
                            break;
                        case </span><span class="html1-value">&quot;-?&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;/?&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;-help&quot;</span><span class="html1-identifier">:
                        case </span><span class="html1-value">&quot;/help&quot;</span><span class="html1-identifier">:
                        default:
                            Console.WriteLine(BaseArgHelp);
                            return;
                    }
                }
                else f++;
            }
            if (f == </span><span class="html1-value">0)
</span><span class="html1-space">            {
                Console.WriteLine(BaseArgHelp);
                return;
            }
            if (bVerbose) Console.WriteLine();
            for (int i = </span><span class="html1-value">0;</span><span class="html1-space"> i &lt; </span><span class="html1-unknownword">args</span><span class="html1-identifier">.Length; i++)
            {
                string arg = </span><span class="html1-value">args[i];
</span><span class="html1-space">                if (arg == </span><span class="html1-value">&quot;.&quot;</span><span class="html1-identifier">) arg = </span><span class="html1-value">Directory.GetCurrentDirectory();
</span><span class="html1-space">                if (!(arg.StartsWith(</span><span class="html1-value">&quot;-&quot;</span><span class="html1-identifier">) || arg.StartsWith(</span><span class="html1-value">&quot;/&quot;</span><span class="html1-identifier">)))
                {
                    if (File.Exists(arg))
                    {
                        EvalFileForCLR(arg, true);
                        if (bNgen)
                        {
                            try
                            {
                                RunNgen(arg, bNgenUninstall, bVerbose);
                            }
                            catch (Exception e)
                            {
                                System.Console.WriteLine(e.Message);
                                return; // abort
                            }
                        }
                    }
                    else if (Directory.Exists(arg))
                    {
                        string[] matches = </span><span class="html1-value">EvalDirForCLR(arg,</span><span class="html1-space"> bFollowSubDirs, true);
                        if (matches.Length &gt; 0)
                        {
                            if (bVerbose) Console.WriteLine(&quot;\r\nFound &quot; + matches.Length + &quot; matches in &quot; + arg + &quot;.\r\n&quot;);
                        }
                        //foreach (string m in matches)
                        //{
                        //    Console.WriteLine(m);
                        //}
                        if (bNgen)
                        {
                            if (bVerbose)
                            {
                                Console.WriteLine();
                                Console.WriteLine(&quot;Executing NGen ...&quot;);
                                Console.WriteLine();
                            }
                            foreach (string m in matches)
                            {
                                try
                                {
                                    RunNgen(m, bNgenUninstall, bVerbose);
                                }
                                catch (Exception ex)
                                {
                                    System.Console.WriteLine(&quot;Error executing NGen: &quot; + ex.Message);
                                    return; // abort
                                }
                            }
                        }
                    }
                }
            }
#if DEBUG
            Console.WriteLine(&quot;Press Enter to continue.&quot;);
            Console.ReadLine();
#endif
        }

        static bool EvalFileForCLR(string file, bool bOutputToConsole)
        {
            try
            {
                AssemblyName.GetAssemblyName(file);
                if (bOutputToConsole) Console.WriteLine(file);
                return true;
            }
            catch
            {
                return false;
            }
        }

        static string[] EvalDirForCLR(string dir, bool bSubdirs, bool bOutputToConsole)
        {
            StringCollection sc = new StringCollection();
            StringCollection files = new StringCollection();
            files.AddRange(Directory.GetFiles(dir, &quot;*.exe&quot;));
            files.AddRange(Directory.GetFiles(dir, &quot;*.dll&quot;));
            foreach (string file in files)
            {
                if (EvalFileForCLR(file, bOutputToConsole))
                {
                    sc.Add(file);
                }
            }
            if (bSubdirs)
            {
                string[] subfolders = Directory.GetDirectories(dir);
                foreach (string sf in subfolders)
                {
                    sc.AddRange(Program.EvalDirForCLR(sf, bSubdirs, true));
                }
            }
            string[] ret = new string[sc.Count];
            sc.CopyTo(ret, 0);
            return ret;
        }

        static void RunNgen(string assem, bool bUninstall, bool bVerbose)
        {
            string curdir = Directory.GetCurrentDirectory();
            Directory.SetCurrentDirectory(Directory.GetParent(assem).FullName);
            string dnpath = System.Environment.GetEnvironmentVariable(&quot;CLRDIR&quot;);
            string sNgen = dnpath + &quot;\\ngen.exe&quot;;
            string sNgenArgs = &quot;&quot;;
            if (bUninstall) sNgenArgs += &quot;uninstall &quot;;
            else sNgenArgs += &quot;install &quot;;
            sNgenArgs += &quot;\&quot;&quot; + assem + &quot;\&quot;&quot;;
            if (bVerbose) Console.WriteLine(&quot;Executing: [ &quot; + sNgen + &quot; &quot; + sNgenArgs + &quot; ]&quot;);
            else Console.WriteLine(sNgen + &quot; &quot; + sNgenArgs);
            System.Diagnostics.ProcessStartInfo spi = new System.Diagnostics.ProcessStartInfo(sNgen, sNgenArgs);
            spi.CreateNoWindow = true;
            spi.RedirectStandardError = true;
            spi.RedirectStandardInput = true;
            spi.RedirectStandardOutput = true;
            spi.UseShellExecute = false;
            System.Diagnostics.Process p = System.Diagnostics.Process.Start(spi);
            if (bVerbose)
            {
                p.OutputDataReceived += new System.Diagnostics.DataReceivedEventHandler(NGen_OutputDataReceived);
                p.BeginOutputReadLine();
            }
            p.WaitForExit();
            Directory.SetCurrentDirectory(curdir);
        }

        static void NGen_OutputDataReceived(object sender, System.Diagnostics.DataReceivedEventArgs e)
        {
            Console.WriteLine(e.Data);
        }
    }
}
</span></span>
</code></pre>

</body>
</html>